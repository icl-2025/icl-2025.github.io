<html>

<head>
<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<link rel="stylesheet" type="text/css" href="../../style.css">
<title>
CSC_52064 - TD 2 - Mini-Python interpreter (in OCaml)
</title>
<style>
tt {
        color:blue;
}
pre {
        color:blue;
}
</style>
</head>

<body>

<h1>CSC_52064 - TD 2 -  Mini-Python interpreter (in OCaml)</h1>

The goal of this lab is to build an interpreter for a simple fragment
of Python, called <b>mini-Python</b>. You don't have to know Python.

<p>

To help you building this interpreter, we provide the basic structure
(as a set of OCaml files together with <tt>Makefile</tt>
and <tt>dune</tt>),
to be downloaded here: <a href="mini-python.tar.gz">mini-python.tar.gz</a>.

<p>

Once uncompressed (with <tt>tar zxvf mini-python.tar.gz</tt>), you get
a directory <tt>mini-python/</tt> with the following files:
<center>
<table border="yes">
<tr><td>ast.ml <td> abstract syntax of <b>mini-Python</b> (complete)
<tr><td>lexer.mll <td> lexical analysis (complete)
<tr><td>parser.mly <td> parsing (complete)
<tr><td>interp.ml <td> interpreter (<font color="red">to be completed</font>)
<tr><td>minipython.ml <td> main file (complete)
<tr><td>Makefile/dune <td> to automate the build (complete)
</table>
</center>
<p>
The code compiles (run <tt>make</tt>, that launches
<tt>dune build</tt>) but is incomplete.
You have to complete <tt>interp.ml</tt>.
<p>

The executable takes a <b>mini-Python</b> file on the command line,
with suffix <tt>.py</tt>. When it is absent, file <tt>test.py</tt> is used.
When running <tt>make</tt>, the interpreter is run on file <tt>test.py</tt>.

<p>

A <b>mini-Python</b> file has the following structure:
<pre>
# zero, one or several function definitions at the beginning of the file
def fibaux(a, b, k):
    if k == 0:
        return a
    else:
        return fibaux(b, a+b, k-1)

def fib(n):
    return fibaux(0, 1, n)

# then one or several statements at the end of the file
print("a few values of the Fibonacci sequence:")
for n in [0, 1, 11, 42]:
    print(fib(n))
</pre>
More generally, a <b>mini-Python</b> file is composed
of an optional list of function definitions, followed by a list of statements.
Caveat: the last statement must be followed by a newline.

Statements are: assignment, conditional, loop
(<tt>for</tt>), output with <tt>print</tt>, returning a value
with <tt>return</tt>, and evaluation an expression.
Expressions are: a constant (Boolean, integer, or string),
access to a variable,
building a list (with syntax <tt>[e1, e2,
  ..., en]</tt>), access to a list element (with syntax
notation <tt>e[i]</tt>), function call, or one of the operations
<tt>+</tt>, <tt>-</tt>, <tt>*</tt>, <tt>//</tt>,
<tt>==</tt>, <tt><></tt>, <tt><</tt>, <tt><=</tt>, <tt>></tt>,
<tt>>=</tt>, <tt>and</tt>, <tt>or</tt> and <tt>not</tt>.

<p>

We also consider three built-in functions: <tt>list(range(n))</tt>
builds the list <tt>[0, 1, 2, ..., n-1]</tt> and <tt>len(l)</tt>
returns the length of list <tt>l</tt>. (We only use
<tt>list</tt> and <tt>range</tt> jointly in this way.)

<h4>Question 1. Arithmetic Expressions</h4>

For the moment, we only consider arithmetic expressions without variables.
Complete function <tt>expr</tt> to evaluate such
expressions (and ignore argument <tt>ctx</tt> to function <tt>expr</tt>).

<p>

Test on the following file
<pre>
print(1 + 2*3)
print((3*3 + 4*4) // 5)
print(10-3-4)
</pre>
whose output must be
<pre>
7
5
3
</pre>

Division and modulus operations must signal a division by zero,
using function <tt>error</tt> provided in file <tt>interp.ml</tt>.

<p>

To test, simply edit file <tt>test.py</tt> and
run <tt>make</tt>. This recompiles the interpreter
and runs it on file <tt>test.py</tt>.

<h4>Question 2. Boolean Expressions and Conditionals</h4>

Complete functions <tt>is_true</tt> and <tt>is_false</tt>, which
respectively decide whether a value is true or false.
In Python, the value <tt>None</tt>, the Boolean <tt>False</tt>,
the integer <tt>0</tt>, the empty string <tt>""</tt> and the empty list
<tt>[]</tt> are all considered false, and any other value is
considered true.

<p>

Then complete function <tt>expr</tt> to interpret Boolean constants,
arithmetic comparison and operations
<tt>and</tt>, <tt>or</tt> and <tt>not</tt>.
In Python, comparison is structural; you can use
the structural comparison of OCaml to do so, that means using
OCaml's operation <tt>&lt;</tt> on values of type <tt>value</tt>.
(This is not 100% compatible with Python, but this will be addressed later.)

<p>

Finally, complete function <tt>stmt</tt>
to interpret the conditional (construction <tt>Sif</tt>).

<p>

Test on the following file
<pre>
print(not True and 1//0==0)
print(1<2)
if False or True:
    print("ok")
else:
    print("oups")
</pre>
whose output must be
<pre>
False
True
ok
</pre>

<h4>Question 3. Variables</h4>

To handle variables (global variables but also local variables and
parameters) we are going to use an
<i>environment</i>, namely
a hash table that is passed to functions
<tt>expr</tt> and <tt>stmt</tt> under the name
<tt>ctx</tt>. This table maps each known variable to its value.
It is implemented by module <tt>Hashtbl</tt> from the OCaml standard
library, and has type
<pre>
  (string, value) Hashtbl.t
</pre>
Complete function <tt>expr</tt> so that we can access variables.
This is pattern <tt>Eident id</tt>.
Accessing a variable that is not in the map must raise an error.

<p>

Similarly, complete function <tt>stmt</tt> so that we can assign a
value to a variable.
This is pattern <tt>Sassign (id, e1)</tt>. This time, the variable may
or may not be in the table. In the former case, its value is modified.
In the latter case, it is added.

<p>

Finally, complete function <tt>expr</tt> so that we can concatenate
two strings with operation <tt>+</tt>.

<p>

Test on the following file
<pre>
x = 41
x = x+1
print(x)
b = True and False
print(b)
s = "hello" + " world!"
print(s)
</pre>
whose output must be
<pre>
42
False
hello world!
</pre>


<h4>Question 4. Functions</h4>

We now consider function definitions and calls.
Functions are stored in the following global hash table:
<pre>
let functions = (Hashtbl.create 17 : (string, ident list * stmt) Hashtbl.t)
</pre>
Each function name is mapped to a pair consisting of
the list of its parameters and its body (a statement).
Complete function <tt>file</tt> so that it fills this table
with functions contained in list <tt>dl</tt>.

<p>

Then complete function <tt>expr</tt> and <tt>stmt</tt> to
interpret a call to a function.
For a call
<tt>f(e1,...,en)</tt> to a function <tt>f</tt> defined as
<tt>def f(x1,...,xn): body</tt>,
we have to build a <i>new</i>
environment that maps each formal parameter <tt>xi</tt> to the value of
<tt>ei</tt>. Then we interpret
the statement <tt>body</tt> (the body of the function) in this new
environment.
The statement <tt>return</tt> is interpreted using
the OCaml exception <tt>Return</tt> (already defined).
If the execution terminates without an explicit <tt>return</tt>, the
value <tt>None</tt> must be returned.

<p>

Test on the following file
<pre>
def fact(n):
    if n <= 1: return 1
    return n * fact(n-1)

print(fact(10))
</pre>
whose output must be
<pre>
3628800
</pre>


<h4>Question 5. Lists</h4>

Add support for lists. To do so,
complete function <tt>expr</tt> so that we can concatenate
two lists with operation <tt>+</tt>, to interpret calls
to <tt>len</tt> (length of a list)
and <tt>list(range(n))</tt> (the list <tt>[0, 1, 2, ..., n-1]</tt>),
and to interpret expressions <tt>[e1, e2, ..., en]</tt> and
<tt>e1[e2]</tt>.

<p>

Complete function <tt>stmt</tt> to interpret
the assignment of a list element
(pattern <tt>Sset (e1, e2, e3)</tt>).

<p>

Finally, complete function <tt>stmt</tt> to interpret
the <tt>for</tt> loop. The statement <tt>Sfor(x,e,s)</tt> successively
assigns to the variable <tt>x</tt> the values of the list <tt>e</tt>,
and executes the statement
<tt>s</tt> for each of them. The expression <tt>e</tt> must be
evaluated only once.

<p>

Test using the program at the beginning of this page. The output must be:
<pre>
0
1
89
267914296
</pre>


<h4>Question 5. Other tests</h4>

Positive and negative tests are provided.
To run your interpreter on these tests, launch <tt>make tests</tt>.

<h4>Question 6 (bonus). Structural Comparison</h4>

On lists, the structural comparison of Python does not coincide with
the OCaml structural comparison of values of type <tt>value array</tt>.
Indeed, OCaml first compares lengths, then elements.
As a consequence, OCaml declares that <tt>[|0;1;1|]</tt> is greater
than <tt>[|1|]</tt>, while Python
declares that <tt>[0,1,1]</tt> is smaller than
<tt>[1]</tt> (lexicographic order).

<p>

Implement a function <tt>compare_value: value -> value -> int</tt>
to compare two Python values. It returns a negative integer
(resp. zero, resp. a positive integer) when the first value is smaller
(resp. equal, resp. greater) than the second value.
Use a Python interpreter as a reference to get the semantics right.
Use <tt>compare_values</tt> to fix what your answer to question 2.

<p>

Do a few tests by yourself.


<div style="text-align:right">
<a href="">solution</a>
</div>

<hr>

<font size="-1"><a href="../../index.html">back to the main page</a></font>

</body>
</html>

<!--
Local Variables:
ispell-local-dictionary: "american"
End:
-->
